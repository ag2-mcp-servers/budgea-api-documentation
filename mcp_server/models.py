# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T17:09:10+00:00

from __future__ import annotations

from datetime import date as date_aliased
from datetime import datetime as datetime_aliased
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class Access(BaseModel):
    email: Optional[str] = None
    id: int
    id_profile: int
    id_role: Optional[int] = None
    id_user: Optional[int] = None


class Account(BaseModel):
    balance: float = Field(..., description='Balance of the account')
    bookmarked: int = Field(..., description='This account has been bookmarked by user')
    coming: Optional[float] = Field(
        0, description='Amount of coming operations not yet debited'
    )
    company_name: Optional[str] = Field(
        None,
        description='Name of the company holding the employee savings of the account',
    )
    currency: Optional[Dict[str, Any]] = Field(None, description='Account currency')
    deleted: Optional[datetime_aliased] = Field(
        None, description='This account is not found on the website anymore'
    )
    disabled: Optional[datetime_aliased] = Field(
        None,
        description='This account has been deleted by user and will not be synchronized anymore',
    )
    display: bool = Field(..., description='Display this account in accounts list')
    error: Optional[str] = Field(
        None, description='If the last update has failed, the error code'
    )
    iban: Optional[str] = Field(None, description='Account IBAN')
    id: int = Field(..., description='ID of the account')
    id_connection: Optional[int] = Field(
        None, description='ID of the related connection'
    )
    id_parent: Optional[int] = Field(None, description='Id of the parent account')
    id_source: Optional[int] = Field(
        None, description='ID of the related connection source'
    )
    id_type: Optional[int] = Field(None, description='ID of the account type')
    id_user: Optional[int] = Field(None, description='ID of the related user')
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last successful update of the account'
    )
    name: Optional[str] = Field(None, description='Name of the account')
    number: Optional[str] = Field(None, description='Account number')
    opening_date: Optional[date_aliased] = Field(
        None, description='Opening date of the account'
    )
    original_name: str = Field(
        ..., description='Original name of the account on the bank'
    )
    ownership: Optional[str] = Field(
        None, description='Relationship between the credentials owner and the account'
    )
    usage: Optional[str] = Field(
        None,
        description='Account usage (if not set by the user, displays the value of original_usage)',
    )
    webid: Optional[str] = Field(None, description='Account webid')


class AccountLog(BaseModel):
    balance: float = Field(..., description='Balanced recorded')
    coming: Optional[float] = Field(0, description='Coming debit recorded')
    error: Optional[str] = Field(None, description='If fail, contains the error code')
    error_message: Optional[str] = Field(
        None, description='If fail, error message received from bank or provider'
    )
    id: int = Field(..., description='ID of the log')
    id_account: int = Field(..., description='ID of the related account')
    id_connection_log: Optional[int] = Field(
        None, description='ID of the related connection log'
    )
    id_connector: Optional[int] = Field(None, description='provider id')
    timestamp: datetime_aliased = Field(..., description='Timestamp of log')


class AccountType(BaseModel):
    color: Optional[str] = Field(
        None, description='Color of the account type (hexdecimal)'
    )
    display_name: str = Field(..., description='Name to display in singular')
    display_name_p: str = Field(..., description='Name to display in plurial')
    id: int = Field(..., description='ID of the account type')
    id_parent: Optional[int] = Field(None, description='Id of the parent type')
    is_invest: bool = Field(..., description='Is it an investment account')
    name: str = Field(..., description='Name of the account type')
    product: Optional[str] = Field(
        None, description='Product associated with the account'
    )
    weboob_type_id: int = Field(..., description='Map to the weboob_type_id')


class Alert(BaseModel):
    id: int
    id_account: Optional[int] = Field(None, description='ID of the related account')
    id_investment: Optional[int] = Field(
        None, description='ID of the related investment'
    )
    id_transaction: Optional[int] = Field(
        None, description='ID of the related transaction'
    )
    id_user: int = Field(..., description='ID of the related user')
    timestamp: datetime_aliased = Field(..., description='Date of the alerts emission')
    type: str = Field(..., description='Type of the alert')
    value: float = Field(..., description='Amount related to the alert')


class AuthProvider(BaseModel):
    id: int
    name: str = Field(..., description='Name to differentiate the authentication type')
    type: str = Field(
        ..., description='Authentication type to use when pushing the webhook'
    )


class Category(BaseModel):
    color: str = Field(..., description='Color of the category')
    id: int = Field(..., description='ID of the category')
    id_logo: Optional[int] = Field(None, description='ID of the logo')
    id_parent_category: int = Field(
        ...,
        description='ID of the parent category. If this is a parent category, it will be equal to its own ID',
    )
    id_parent_category_in_menu: int = Field(
        ..., description='ID of the parent category to be displayed'
    )
    id_user: Optional[int] = Field(
        None, description='If not null, this category is specific to a user'
    )
    income: Optional[bool] = Field(
        None,
        description='Is an income category. If null, this is both an income and an expense category',
    )
    name: str = Field(..., description='Name of the category')
    name_displayed: Optional[str] = Field(
        None, description='Displayed name, with HTML tags'
    )
    refundable: bool = Field(
        ..., description='This category accepts opposite sign of transactions'
    )


class Certificate(BaseModel):
    created: datetime_aliased
    id: int
    id_private_key_file: int
    id_public_key_file: int
    type: str


class Client(BaseModel):
    config: Optional[str] = Field(None, description='customizable config')
    id: int
    id_logo: Optional[int] = None
    name: str
    private_key: Optional[str] = None
    pro: bool = Field(
        ..., description='Should the client display the company manager page.'
    )
    public_key: Optional[str] = None
    redirect_uris: str
    secret: str


class ConfigLog(BaseModel):
    id: int
    key: str
    new_value: Optional[str] = None
    origin: Optional[str] = Field(
        None, description='The entity who made the config key modification'
    )
    previous_value: Optional[str] = None
    timestamp: datetime_aliased = Field(
        ..., description='Timestamp of when the configuration key was changed'
    )
    type: str = Field(
        ..., description='Action done on the config: add, update or delete'
    )


class Connection(BaseModel):
    active: bool = Field(
        ..., description='This connection is active and will be automatically synced'
    )
    created: Optional[datetime_aliased] = Field(
        '<function datetime.now at 0x7f5740f1ad90>', description='Creation date'
    )
    id: int = Field(..., description='ID of connection')
    id_connector: int = Field(..., description='ID of the related connector')
    id_user: Optional[int] = Field(None, description='ID of the related user')
    last_push: Optional[datetime_aliased] = Field(
        None, description='Last successful push'
    )
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last successful update'
    )
    next_try: Optional[datetime_aliased] = Field(
        None, description='Date of next synchronization'
    )


class ConnectionLog(BaseModel):
    error: Optional[str] = Field(None, description='If fail, contains the error code')
    error_message: Optional[str] = Field(
        None, description='If fail, error message received from connector'
    )
    error_uid: Optional[str] = Field(
        None, description='MD5 hash of the exception backtrace'
    )
    fields: Optional[str] = Field(
        None,
        description='Fields for connection in additionalInformationNeeded state with background option',
    )
    id: int = Field(..., description='ID of the log')
    id_connection: int = Field(..., description='ID of the connection')
    id_connector: Optional[int] = Field(None, description='ID of the connector')
    id_source: Optional[int] = Field(
        None, description='ID of the related connection source'
    )
    id_user: Optional[int] = Field(None, description='ID of the user')
    login: Optional[str] = Field(None, description='bcrypt hash of the login')
    nb_accounts: Optional[int] = Field(
        None, description='In case of bank connection, number of accounts'
    )
    next_try: Optional[datetime_aliased] = Field(
        None, description='If fail, the date represents the next try to connect'
    )
    session_folder_id: Optional[str] = Field(None, description='Session folder uid')
    start: Optional[datetime_aliased] = Field(
        None, description='Timestamp when the synchronization has started'
    )
    statut: Optional[int] = Field(None, description='Status of user (1 = charged user)')
    timestamp: datetime_aliased = Field(
        ..., description='Timestamp of log, when the synchronization has finished'
    )
    worker: Optional[str] = Field(None, description='Worker used to do synchronization')


class ConnectionSource(BaseModel):
    access_expire: Optional[datetime_aliased] = Field(
        None, description='Expiration date of the access'
    )
    created: datetime_aliased = Field(
        ..., description='Creation date of the connection source'
    )
    disabled: Optional[datetime_aliased] = Field(
        None, description='This source is not used to synchronize the connection'
    )
    expire: Optional[datetime_aliased] = Field(
        None,
        description='Expiration of the connection source. Used to purge the connection in case completion was not finished',
    )
    id: int = Field(..., description='ID of connection')
    id_connection: int = Field(..., description='ID of the related connection')
    id_connector_source: int = Field(
        ..., description='ID of the related connector source'
    )
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last successful update'
    )
    name: str = Field(..., description='Name of the connection source')
    next_try: Optional[datetime_aliased] = Field(
        None, description='Date of next synchronization'
    )
    state: Optional[str] = Field(
        None, description='If the last update has failed, the state code'
    )


class Connector(BaseModel):
    auth_mechanism: Optional[str] = Field(
        None, description='Authentication mechanism to use'
    )
    beta: bool = Field(
        ..., description='If true, this connector is perhaps unstable :)'
    )
    charged: bool = Field(..., description='Usage of this connector is charged')
    code: Optional[str] = Field(None, description='Bank code')
    color: Optional[str] = Field(None, description='Main color of the bank or provider')
    hidden: Optional[bool] = Field(
        False, description='This connector is hidden from your users'
    )
    id: int = Field(..., description='ID of the connector')
    months_to_fetch: Optional[int] = Field(
        None, description='How many months of history to fetch'
    )
    name: str = Field(..., description='Name of the bank or provider')
    restricted: bool = Field(
        ..., description='If true, new connections cannot be added with this connector'
    )
    siret: Optional[str] = Field(None, description='SIRET code for Bill modules')
    slug: Optional[str] = None
    sync_frequency: Optional[float] = Field(
        None, description='How many days to wait between syncs'
    )
    uuid: str = Field(..., description='Unique connector identifier')


class ConnectorCategory(BaseModel):
    id: int = Field(..., description='ID of the bank category')
    name: str = Field(..., description='Name of the category')


class ConnectorLogo(BaseModel):
    id: int
    id_connector: int = Field(..., description='ID of the connector')
    id_file: int = Field(..., description='Id of the Bank/Provider Logo')
    type: Optional[str] = Field(None, description="Logo's type")


class ConnectorSource(BaseModel):
    auth_mechanism: Optional[str] = Field(
        None, description='Authentication mechanism to use'
    )
    disabled: Optional[datetime_aliased] = Field(
        None, description='This source is not used to synchronize the connection'
    )
    disabled_capabilities: Optional[str] = Field(
        None,
        description='Comma separated list of capabilities disabled on this connector source',
    )
    fallback: Optional[str] = Field(
        None, description='Name of the source this fallback is for'
    )
    id: int = Field(..., description='ID of the connector source')
    id_connector: int = Field(..., description='ID of the connector')
    id_weboob: str
    name: str = Field(..., description='Name of the source')
    priority: Optional[int] = Field(
        None, description='The source priority order for the synchronization'
    )
    stability: Optional[str] = Field(None, description='last known stability')


class ConnectorSourceField(BaseModel):
    id_connector_source: int = Field(
        ..., description='ID of the related connector source'
    )
    label: str = Field(..., description='Label to display to user')
    name: str = Field(..., description='Name of the config')
    regex: Optional[str] = Field(
        None, description='If set, the value must match this regexp'
    )
    required: Optional[bool] = Field(
        True, description='If true, config has to be set to use this source'
    )
    secret: Optional[bool] = Field(
        True, description='If true, value must be hidden on fronts'
    )
    type: Optional[str] = Field('text', description='Type of config')


class Currency(BaseModel):
    crypto: Optional[bool] = Field(False, description='It is a crypto currency or not')
    datetime: Optional[datetime_aliased] = Field(
        None, description='Time and date of Market Cap (for cryptos)'
    )
    id: str = Field(..., description='ISO 4217 code used as ID')
    marketcap: Optional[float] = Field(None, description='Market Capitalization in EUR')
    precision: Optional[int] = Field(2, description='Numbers of significant digits')
    prefix: bool = Field(..., description='Amount is prefixed or not by the currency')
    symbol: str = Field(..., description='Symbol representing the currency')


class Device(BaseModel):
    debug: bool
    id: int
    id_token: int
    last_update: datetime_aliased
    notification_token: str
    type: str
    version: str


class Document(BaseModel):
    currency: Optional[Dict[str, Any]] = Field(None, description='Document currency')
    date: Optional[datetime_aliased] = None
    duedate: Optional[date_aliased] = None
    has_file_on_website: bool = Field(
        ..., description='Boolean to set if file is available on website'
    )
    id: int
    id_category: Optional[int] = None
    id_file: Optional[int] = None
    id_subscription: Optional[int] = None
    id_thumbnail: Optional[int] = None
    id_type: Optional[int] = None
    id_user: int
    income: Optional[bool] = True
    issuer: Optional[str] = None
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last successful update of the document'
    )
    name: Optional[str] = None
    number: Optional[str] = None
    readonly: bool
    timestamp: datetime_aliased
    total_amount: Optional[float] = None
    untaxed_amount: Optional[float] = None
    vat: Optional[float] = None
    webid: Optional[str] = None


class DocumentType(BaseModel):
    attacheable: bool
    id: int
    name: str


class FieldModel(BaseModel):
    auth_mechanisms: Optional[str] = Field(
        None, description='Authentication mechanisms this field is used for'
    )
    connector_sources: Optional[str] = Field(
        None, description='Sources this field is used for'
    )
    ephemeral: Optional[bool] = Field(
        False, description='This field will not be saved in database'
    )
    id: int = Field(..., description='ID of the field')
    id_connector: int = Field(..., description='ID of the related connector')
    label: str = Field(..., description='Label to display to user')
    name: str = Field(..., description='Name of the field')
    regex: Optional[str] = Field(
        None, description='If set, the value must match this regexp'
    )
    required: bool = Field(
        ..., description='If true, field has to be set to synchronize the connection'
    )
    type: Optional[str] = Field(
        'text', description='Type of field (text, password, list, hidden)'
    )
    value: Optional[str] = Field(None, description='Default value of the field')


class File(BaseModel):
    content_type: str
    file_size: int
    filename: str
    id: int


class Group(BaseModel):
    color: Optional[str] = None
    conf: Optional[str] = None
    email: Optional[str] = None
    id: int
    id_logo: Optional[int] = None
    id_parent_group: Optional[int] = None
    name: Optional[str] = None
    url: Optional[str] = None


class HashTable(BaseModel):
    display: bool
    income: bool
    nature: str
    wording: str


class IdentityInfo(BaseModel):
    external_ref: Optional[str] = Field(
        None, description='Label associated with the beneficiary account'
    )
    id: int
    id_user: Optional[int] = Field(None, description='ID of a related user')
    identification: Optional[str] = Field(None, description='Identification number')
    issuer: Optional[str] = Field(None, description='issuer of the identification')
    kind: Optional[str] = Field(None, description='Kind of the entity')
    scheme_name: Optional[str] = Field(None, description='Identification number type')


class Investment(BaseModel):
    code: str = Field(..., description='Investment code')
    code_type: Optional[str] = Field(None, description='Code type (ISIN of AMF)')
    deleted: Optional[datetime_aliased] = Field(
        None, description='If set, this investment has been removed from the website'
    )
    description: Optional[str] = Field(
        None, description='Description of the investment'
    )
    diff: Optional[float] = Field(0, description='Capital gain')
    diff_percent: Optional[float] = Field(
        None, description='Capital gain in percent (between 0 and 1)'
    )
    id: int = Field(..., description='ID of the investment')
    id_account: int = Field(..., description='ID of the related account')
    id_security: Optional[int] = Field(None, description='ID of the related security')
    label: str = Field(..., description='Label of the investment')
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last update of the investment'
    )
    original_currency: Optional[Dict[str, Any]] = Field(
        None, description='Original currency'
    )
    original_diff: Optional[float] = Field(
        None, description='Capital gain in the original currency'
    )
    original_unitprice: Optional[float] = Field(
        None, description='Current unit value in the original currency'
    )
    original_unitvalue: Optional[float] = Field(
        None, description='Average buy price in the original currency'
    )
    original_valuation: Optional[float] = Field(
        None, description='Valuation in original currency'
    )
    portfolio_share: Optional[float] = Field(
        None, description='Percent of the portfolio'
    )
    prev_diff: Optional[float] = Field(
        None, description='Capital gain from previous value'
    )
    prev_vdate: Optional[date_aliased] = Field(
        None, description='Value date of the previous value (prev_diff)'
    )
    quantity: Optional[float] = Field(0, description='Quantity')
    source: Optional[str] = Field(
        None, description='Source of the ISIN code (website, notFound)'
    )
    unitprice: Optional[float] = Field(0, description='Average buy price')
    unitvalue: Optional[float] = Field(0, description='Current unit value')
    valuation: Optional[float] = Field(0, description='Current valuation')
    vdate: Optional[date_aliased] = Field(None, description='Value date')


class InvestmentValue(BaseModel):
    id: int = Field(..., description='ID of the value')
    id_investment: int = Field(..., description='ID of the related investment')
    original_currency: Optional[Dict[str, Any]] = Field(
        None, description='Original currency'
    )
    original_unitvalue: Optional[float] = Field(
        None, description='Value on this date, in the original currency'
    )
    unitvalue: float = Field(..., description='Value on this date')
    vdate: date_aliased = Field(..., description='Date of this value')


class Keyword(BaseModel):
    id: int
    id_category: int
    income: bool
    keyword: str
    priority: int


class LockedUser(BaseModel):
    id_user: int
    timestamp: datetime_aliased
    worker: Optional[str] = None


class MarketOrder(BaseModel):
    amount: Optional[float] = Field(0, description='Total amount of the market order')
    code: Optional[str] = Field(
        None, description='ISIN code of the investment associated with the market order'
    )
    created: datetime_aliased = Field(
        ..., description='Insertion date of the market order in bi_market_order'
    )
    date: Optional[date_aliased] = Field(
        None, description='Creation date of the market order'
    )
    deleted: Optional[datetime_aliased] = Field(
        None, description='If set, this market order has been removed from the website'
    )
    execution_date: Optional[date_aliased] = Field(
        None, description='Execution date of the market order'
    )
    id: int = Field(..., description='ID of the market order')
    id_account: int = Field(..., description='ID of the related account')
    label: str = Field(
        ..., description='Label of the investment associated with the market order'
    )
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last update of the market order'
    )
    ordervalue: Optional[float] = Field(
        0,
        description='Limit value or trigger value, only relevant if the order type is LIMIT or TRIGGER',
    )
    payment_method: Optional[str] = Field(
        None,
        description="Payment method for the market order (usually 'SRD' or 'Comptant')",
    )
    quantity: Optional[float] = Field(
        0, description='Quantity of stock shares in the market order'
    )
    state: Optional[str] = Field(None, description='Current state of the market order')
    stock_market: Optional[str] = Field(
        None, description='Stock market on which the order was executed'
    )
    unitprice: Optional[float] = Field(
        0, description='Value of the stock at the moment of the market order'
    )
    unitvalue: Optional[float] = Field(
        0, description='Current value of the stock associated with the market order'
    )
    validity_date: Optional[date_aliased] = Field(
        None, description='Validity date of the market order'
    )
    webid: Optional[str] = Field(None, description='Weboob ID of the market order')


class OidcWhitelist(BaseModel):
    id: int
    redirect_uri: str = Field(..., description='authorized redirect uri')


class Payment(BaseModel):
    client_redirect_uri: Optional[str] = Field(
        None, description='URL to redirecting to client'
    )
    error_code: Optional[str] = Field(
        None, description='In case of error, the error code'
    )
    error_description: Optional[str] = Field(None, description='Error message')
    id: int
    register_date: Optional[datetime_aliased] = Field(
        None, description='Date of payment registration'
    )
    state: Optional[str] = Field(None, description='State of the payment')
    validate_uri: Optional[str] = Field(None, description='URL to validate payment')


class PaymentAccount(BaseModel):
    disabled_date: Optional[datetime_aliased] = Field(
        None, description='Date at which the entry was disabled'
    )
    id: int
    id_account: Optional[int] = Field(None, description='ID of a related account')
    identification: Optional[str] = Field(
        None, description='Account identification number'
    )
    issuer: Optional[str] = Field(
        None, description='Issuer or bic associated with the account'
    )
    label: Optional[str] = Field(
        None, description='Label associated with the beneficiary account'
    )
    scheme_name: Optional[str] = Field(None, description='Account number type')


class PaymentLog(BaseModel):
    error_code: Optional[str] = Field(
        None, description='In case of error, the error code'
    )
    error_description: Optional[str] = Field(None, description='Error message')
    id: int
    id_file: Optional[int] = Field(None, description='ID of the related payment file')
    id_payment: Optional[int] = Field(None, description='ID of the related payment')
    state: Optional[str] = Field(None, description='State of the payment')
    timestamp: datetime_aliased = Field(..., description='Timestamp of the log')


class Pocket(BaseModel):
    availability_date: Optional[date_aliased] = Field(
        None, description='Availability date of the pocket'
    )
    condition: str = Field(..., description='Withdrawal condition of the pocket')
    deleted: Optional[datetime_aliased] = Field(
        None, description='If set, this pocket has been removed from the website'
    )
    id: int = Field(..., description='ID of the pocket')
    id_account: int = Field(..., description='ID of the related account')
    id_investment: int = Field(..., description='ID of the related investment')
    label: Optional[str] = Field(None, description='Label of the pocket')
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last update of the pocket'
    )
    quantity: Optional[float] = Field(0, description='Quantity of stocks')
    value: float = Field(..., description='Value of the pocket')


class Role(Enum):
    admin = 'admin'
    ser = 'ser'


class Profile(BaseModel):
    admin: bool
    conf: Optional[str] = None
    email: str
    id: int
    id_user: int
    lang: Optional[str] = None
    role: Role
    statut: int


class Psd2Registration(BaseModel):
    id: int
    id_connector_source: Optional[int] = Field(
        None, description='ID of the connector source'
    )
    status: str = Field(..., description='Current status: created/updated/error')


class Psd2RegistrationLog(BaseModel):
    created_at: datetime_aliased = Field(..., description='When this row was created')
    error_message: Optional[str] = Field(
        None, description='If fail, error message received from connector'
    )
    id: int
    id_psd2registration: Optional[int] = Field(
        None, description='ID of the psd2 registration'
    )
    type: str = Field(..., description='Action done: create, update, delete')


class Recipient(BaseModel):
    add_verified: Optional[bool] = Field(
        None, description='Was the recipient adding authorized'
    )
    bank_name: Optional[str] = Field(None, description='Bank of the recipient')
    category: str = Field(..., description='Category in which the recipient is')
    currency: Optional[Dict[str, Any]] = Field(
        None, description='Currency of the object'
    )
    deleted: Optional[datetime_aliased] = Field(
        None, description="The recipient isn't found anymore on the bank"
    )
    enabled_at: Optional[datetime_aliased] = Field(
        None,
        description='It will be possible to do transfers to this recipient at this date',
    )
    error: Optional[str] = Field(None, description='Error message')
    expire: Optional[datetime_aliased] = None
    fields: Optional[str] = Field(
        None, description='Fields for recipient with additionalInformationNeeded state'
    )
    iban: Optional[str] = Field(None, description='IBAN of the recipient')
    id: int = Field(..., description='ID of the recipient')
    id_account: int = Field(..., description='ID of the related account')
    id_target_account: Optional[int] = Field(
        None, description='ID of the target account, in case of internal recipient'
    )
    label: str = Field(..., description='Label of the recipient')
    last_update: datetime_aliased = Field(
        ..., description='Last time we have fetched this recipient'
    )
    state: Optional[str] = Field(None, description='State of recipient')
    time_scraped: Optional[datetime_aliased] = Field(
        None, description="First time we've seen this recipient"
    )
    webid: Optional[str] = Field(None, description='Webid of the recipient')


class RecipientLog(BaseModel):
    error: Optional[str] = Field(
        None, description='Error message during recipient addition, if any'
    )
    fields: Optional[str] = Field(
        None,
        description='Fields for recipient in additionalInformationNeeded state with background option',
    )
    id: int = Field(..., description='ID of the transfer log entry')
    id_file: Optional[int] = Field(None, description='ID of the related file')
    id_recipient: Optional[int] = Field(None, description='ID of the related recipient')
    request_data: Optional[str] = Field(
        None,
        description='Data stored related to user who has requested the recipient addition',
    )
    step: Optional[str] = Field(
        None,
        description='Step of recipient addition, (add_recipient, asking_field, recipient addition validated, creation, storing_files)',
    )
    timestamp: datetime_aliased = Field(..., description='Timestamp of the log')


class Security(BaseModel):
    code: Optional[str] = Field(None, description='ISIN code of the security')
    id: int = Field(..., description='ID of the security')
    id_type: Optional[int] = Field(None, description='ID of the security type')
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last update of the security'
    )
    name: str = Field(..., description='Name of the security')


class Subscription(BaseModel):
    deleted: Optional[datetime_aliased] = Field(
        None, description='This subscription is not found on the website anymore'
    )
    disabled: Optional[datetime_aliased] = Field(
        None,
        description='This subscription has been deleted by user and will not be synchronized anymore',
    )
    error: Optional[str] = Field(
        None, description='If the last update has failed, the error code'
    )
    id: int = Field(..., description='ID of subscription')
    id_connection: Optional[int] = Field(None, description='ID of related connection')
    id_source: Optional[int] = Field(
        None, description='ID of the related connection source'
    )
    id_user: Optional[int] = Field(None, description='ID of related user')
    label: str = Field(..., description='Label of the subscription')
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last successful update of the subscription'
    )
    number: str = Field(..., description="Subscription's number")
    renewdate: Optional[date_aliased] = Field(
        None, description='Next renew date, if any'
    )
    subscriber: Optional[str] = Field(None, description='Name of the subscriber')
    validity: Optional[date_aliased] = Field(
        None, description='The subscription is valid until this date, if any'
    )


class SubscriptionLog(BaseModel):
    error: Optional[str] = Field(None, description='If fail, contains the error code')
    error_message: Optional[str] = Field(
        None, description='If fail, error message received from provider'
    )
    id: int = Field(..., description='ID of the log')
    id_connection_log: Optional[int] = Field(
        None, description='ID of the related connection log'
    )
    id_source: Optional[int] = Field(
        None, description='ID of the related connection source'
    )
    id_subscription: int = Field(..., description='ID of the related subscription')
    nb_docs: Optional[int] = Field(
        None, description='Number of docs on the subscription'
    )
    timestamp: datetime_aliased = Field(..., description='Timestamp of log')


class TermsOfService(BaseModel):
    created: datetime_aliased
    deleted: Optional[datetime_aliased] = None
    id: int
    version: str


class Transaction(BaseModel):
    active: bool = Field(
        ..., description='If false, PFM services will ignore this transaction'
    )
    application_date: Optional[date_aliased] = Field(
        None,
        description='Date considered by PFM services. It is used to change the month of a transaction, for example.',
    )
    bdate: Optional[date_aliased] = Field(
        None, description='Date used by the bank for the transaction'
    )
    bdatetime: Optional[datetime_aliased] = Field(
        None, description='Datetime used by the bank'
    )
    card: Optional[str] = Field(
        None, description='Card number associated to the transaction'
    )
    coming: bool = Field(
        ..., description="If true, this transaction hasn't been yet debited"
    )
    comment: Optional[str] = Field(None, description='User comment')
    commission: Optional[float] = Field(
        None, description='Commission taken on the transaction'
    )
    commission_currency: Optional[Dict[str, Any]] = Field(
        None, description='Commission currency'
    )
    counterparty: Optional[str] = Field(None, description='Counterparty')
    country: Optional[str] = Field(None, description='Original country')
    date: date_aliased = Field(..., description='Debit date')
    date_scraped: datetime_aliased = Field(
        ..., description='Date when the transaction has been seen'
    )
    datetime: Optional[datetime_aliased] = Field(
        None, description='Datetime of the debit of the transaction'
    )
    deleted: Optional[datetime_aliased] = Field(
        None, description='If set, this transaction has been removed from the bank'
    )
    gross_value: Optional[float] = Field(
        None, description='Gross value of the transaction'
    )
    id: int = Field(..., description='ID of the transaction')
    id_account: int = Field(..., description='ID of the related account')
    id_category: Optional[int] = Field(None, description='ID of the related category')
    id_cluster: Optional[int] = Field(
        None, description='If the transaction is part of a cluster'
    )
    last_update: Optional[datetime_aliased] = Field(
        None, description='Last update of the transaction'
    )
    nature: str = Field(..., description='Type of transaction')
    original_currency: Optional[Dict[str, Any]] = Field(
        None, description='Original currency'
    )
    original_gross_value: Optional[float] = Field(
        None, description='Gross value in the original currency'
    )
    original_value: Optional[float] = Field(
        None, description='Value in the original currency'
    )
    original_wording: str = Field(..., description='Full label of the transaction')
    rdate: date_aliased = Field(..., description='Realization of the transaction')
    rdatetime: Optional[datetime_aliased] = Field(
        None, description='Datetime of the realization of the transaction'
    )
    simplified_wording: str = Field(
        ..., description='Simplified label of the transaction'
    )
    state: str = Field(..., description='Internal state of the transaction')
    stemmed_wording: str = Field(..., description='Do not use it')
    value: Optional[float] = Field(None, description='Value of the transaction')
    vdate: Optional[date_aliased] = Field(
        None, description='Value date of the transaction'
    )
    vdatetime: Optional[datetime_aliased] = Field(
        None, description='Datetime of the Value of the transaction'
    )
    webid: Optional[str] = Field(None, description='Webid of the transaction')
    wording: Optional[str] = Field(None, description='Label set by the user')


class TransactionInformation(BaseModel):
    id: int = Field(..., description='ID of this transaction information')
    id_transaction: int = Field(..., description='ID of the related transaction')
    key: str = Field(..., description='Key of the transaction information')
    value: Optional[str] = Field(
        None, description='Value of the transaction information'
    )


class TransactionsCluster(BaseModel):
    created_by: Optional[str] = None
    enabled: bool
    id: int
    id_account: int
    id_category: Optional[int] = None
    mean_amount: float
    median_increment: Optional[int] = None
    next_date: Optional[date_aliased] = None
    wording: str


class Transfer(BaseModel):
    account_balance: Optional[float] = Field(
        None, description='Balance of the account just before the transfer'
    )
    account_iban: Optional[str] = Field(None, description='IBAN of the debited account')
    amount: float = Field(..., description='Amount of the transfer')
    beneficiary_label: Optional[str] = Field(
        None,
        description="Label of the beneficiary (needed for transfer to other beneficiary type than 'recipient')",
    )
    beneficiary_number: Optional[str] = Field(
        None,
        description='Beneficiary bank identifier value like recipient webid, iban: EX6713281847025300290000062 or phone_number: 06XXXXXX',
    )
    beneficiary_type: str = Field(
        ...,
        description="Type of beneficiary number, for example: 'recipient' (in bank recipient list), 'iban' or 'phone_number'",
    )
    currency: Optional[Dict[str, Any]] = Field(
        None, description='Currency of the object'
    )
    error: Optional[str] = Field(
        None, description='Error message during transfer, if any'
    )
    exec_date: date_aliased = Field(
        ..., description='Date when the transfer will be operated by the bank'
    )
    fees: Optional[float] = Field(None, description='Fees taken by the bank')
    id: int = Field(..., description='ID of transfer')
    id_account: Optional[int] = Field(None, description='ID of the debited account')
    id_recipient: Optional[int] = Field(None, description='ID of the recipient')
    id_transaction: Optional[int] = Field(
        None, description='If found, ID of the related transaction'
    )
    id_user: Optional[int] = Field(None, description='ID of the related user')
    label: Optional[str] = Field(None, description='Label of the transfer')
    recipient_iban: Optional[str] = Field(
        None, description='IBAN of the recipient in bank recipient list'
    )
    register_date: datetime_aliased = Field(
        ..., description='Date when the transfer has been registered'
    )
    state: str = Field(
        ...,
        description='State of the transfer (created, scheduled, validating, pending, coming, done, canceled, transactionNotFound, deleted, error, bug)',
    )
    validate_mechanism: Optional[str] = Field(
        None,
        description='Authentication method used to validate transfer (credentials or webauth)',
    )
    webid: Optional[str] = Field(None, description='WebID of the transfer')


class TransferLog(BaseModel):
    error: Optional[str] = Field(
        None, description='Error message during transfer, if any'
    )
    fields: Optional[str] = Field(
        None,
        description='Fields for transfer in additionalInformationNeeded state with background option',
    )
    id: int = Field(..., description='ID of the transfer log entry')
    id_file: Optional[int] = Field(None, description='ID of the related file')
    id_transfer: Optional[int] = Field(None, description='ID of the related transfer')
    request_data: Optional[str] = Field(
        None, description='Data stored related to user who has requested the transfer'
    )
    state: Optional[str] = Field(
        None,
        description='State of the transfer (created, scheduled, validating, pending, done, canceled, error, bug)',
    )
    timestamp: datetime_aliased = Field(..., description='Timestamp of the log')


class Platform(Enum):
    web = 'web'
    iPad = 'iPad'
    iPhone = 'iPhone'
    Android = 'Android'
    CAstore = 'CAstore'
    requestAccess = 'requestAccess'
    sharedAccess = 'sharedAccess'
    singleAccess = 'singleAccess'
    transfer = 'transfer'
    refresh_token = 'refresh_token'


class User(BaseModel):
    id: int
    platform: Platform
    signin: datetime_aliased


class UserAlert(BaseModel):
    apply: Optional[str] = None
    balance_max: Optional[float] = 10000
    balance_min1: Optional[float] = 500
    balance_min2: Optional[float] = 0
    date_range: Optional[int] = None
    enabled: Optional[bool] = True
    expense_max: Optional[float] = 500
    id: int
    income_max: Optional[float] = 500
    resume_enabled: Optional[bool] = True
    resume_frequency: int
    transaction_types: Optional[str] = None
    type: str
    value_type: str


class Webhook(BaseModel):
    add_to_data: Optional[str] = Field(
        None, description='json value to describe data to add'
    )
    created: datetime_aliased = Field(..., description='Date of the webhook creation')
    deleted: Optional[datetime_aliased] = Field(
        None, description='Date of the webhook deletion'
    )
    flush_fail: Optional[str] = Field(
        None, description='json value to store last related webhook data flushing fail'
    )
    id: int = Field(..., description='ID of the webhook')
    id_auth: Optional[int] = Field(None, description='ID of the authentication process')
    id_event: Optional[int] = Field(None, description='ID of the webhook event')
    id_service: Optional[int] = Field(None, description='ID of the service')
    id_user: Optional[int] = Field(None, description='ID of the emitter user')
    updated: datetime_aliased = Field(
        ..., description='Date of the webhook last update'
    )
    url: Optional[str] = Field(None, description='URL of the webhook')


class WebhookData(BaseModel):
    created: datetime_aliased = Field(
        ..., description='Timestamp when the hook data was generated'
    )
    data: Optional[str] = Field(None, description='Data emitted')
    id: int = Field(..., description='ID of the webhook data')
    id_resource: Optional[int] = Field(
        None,
        description='a changing ID used to filter webhookdata depending on the event triggered',
    )
    id_service: Optional[int] = Field(None, description='ID of the recipient service')
    id_user: Optional[int] = Field(None, description='ID of the emitter user')
    id_webhook: Optional[int] = Field(None, description='ID of the webhook')
    mimetype: Optional[str] = Field(None, description='Mimetype of the data')
    success: Optional[datetime_aliased] = Field(
        None, description='Timestamp when the hook has been successfully called'
    )


class WebhookLog(BaseModel):
    id: int = Field(..., description='ID of the log')
    id_service: Optional[int] = Field(None, description='ID of the service')
    id_user: Optional[int] = Field(None, description='ID of the user')
    id_webhook_data: Optional[int] = Field(None, description='ID of the webhook data')
    next_try: Optional[datetime_aliased] = Field(
        None,
        description='If the log is an error, do not retry to push before this timestamp',
    )
    response_code: Optional[int] = Field(
        None, description='Return code of the reply to the hook'
    )
    response_date: Optional[datetime_aliased] = Field(
        None, description='Timestamp of the reply to the hook'
    )
    timestamp: datetime_aliased = Field(
        ..., description='Timestamp when the hook was sent'
    )


class AccountTypesGetResponse(BaseModel):
    accounttypes: List[AccountType]
    total: Optional[float] = Field(None, description='total number of results')


class AdminJwtPostRequest(BaseModel):
    duration: Optional[int] = Field(
        None,
        description="number of minute before the token expiration (0 for token that won't expire unless the client application is deleted) (default: 1)",
    )
    scope: Optional[str] = Field(
        None, description='scope requested for the token (default: config)'
    )


class AdminJwtPostResponse(BaseModel):
    pass


class AuthInitPostRequest(BaseModel):
    client_id: Optional[str] = Field(None, description='ID of the client')
    client_secret: Optional[str] = Field(None, description='secret of the client')


class AuthInitPostResponse(BaseModel):
    auth_token: str = Field(
        ..., description='new token created for the new anonymous user'
    )
    expires_in: Optional[int] = Field(
        None, description='duration in seconds of the token validity'
    )
    type: str = Field(..., description='type of the token')


class AuthJwtPostRequest(BaseModel):
    client_id: Optional[str] = Field(None, description='id of the client')
    client_secret: Optional[str] = Field(None, description='secret for the client')
    expire: Optional[bool] = Field(
        None,
        description='if set to True, the token will expire n minutes after its creation, n being the value of configuration key auth.default_token_expire (default: True)',
    )
    id_user: Optional[int] = Field(
        None,
        description='user for whom the token has to be generated. If not supplied, a user will be created',
    )
    scope: Optional[str] = Field(None, description='scope requested for the token')


class AuthJwtPostResponse(BaseModel):
    jwt_token: str = Field(..., description='the jwt token')
    payload: Dict[str, Any] = Field(
        ..., description='the payload contained in the jwt token'
    )


class AuthRenewPostRequest(BaseModel):
    client_id: str = Field(..., description='ID of the client')
    client_secret: str = Field(..., description='secret of the client')
    grant_type: Optional[str] = Field(
        None, description='default is "client_credentials"'
    )
    id_user: int = Field(..., description='id of the user to generate a token for')
    revoke_previous: Optional[bool] = Field(
        None,
        description='if true, all other permanent tokens for the user will be deleted',
    )


class AuthRenewPostResponse(BaseModel):
    access_token: str = Field(
        ..., description='the access token transformed from the temporary one'
    )
    token_type: str = Field(..., description='the access token type')


class AuthTokenPostRequest(BaseModel):
    application: str = Field(..., description='application name')
    grant_type: Optional[str] = Field(
        None,
        description='password when requesting a user token and client_credentials for a payment manage token (default: password)',
    )
    password: str = Field(..., description='password')
    scope: Optional[str] = Field(None, description='scope requested for the token')
    username: str = Field(..., description='username')


class AuthTokenPostResponse(BaseModel):
    expires_in: Optional[int] = Field(
        None, description='duration in seconds of the token validity'
    )
    scope: str = Field(..., description='the token scope')
    token: str = Field(..., description='the requested token')


class AuthTokenAccessPostRequest(BaseModel):
    client_id: str = Field(..., description='ID of the client')
    client_secret: str = Field(..., description='secret of the client')
    code: str = Field(..., description="user's temporary code")
    grant_type: Optional[str] = Field(
        None, description='default is "authorization_code"'
    )
    redirect_uri: Optional[str] = Field(None, description='redirect uri used by user')


class AuthTokenAccessPostResponse(BaseModel):
    access_token: str = Field(
        ..., description='the access token transformed from the temporary one'
    )
    token_type: str = Field(..., description='the access token type')


class AuthTokenCodeGetResponse(BaseModel):
    access: str = Field(
        ..., description='the reusability of a token (standard or single use)'
    )
    code: str = Field(..., description='the temporary token')
    expires_in: int = Field(
        ..., description='duration in seconds of the token validity'
    )
    type: Dict[str, Any] = Field(..., description='the token type')


class BanksGetResponse(BaseModel):
    banks: List[Connector]
    total: Optional[float] = Field(None, description='total number of results')


class BanksCategoriesPostRequest(BaseModel):
    name: str = Field(..., description='name of the category to be created')


class BanksCategoriesIdCategoryPostRequest(BaseModel):
    name: str = Field(..., description='new name for the supplied category')


class BanksIdConnectorConnectionsGetResponse(BaseModel):
    connections: List[Connection]
    total: Optional[float] = Field(None, description='total number of results')


class BanksIdConnectorLogosGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class BanksIdConnectorLogosMainGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class BanksIdConnectorLogosThumbnailGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class BanksIdConnectorSourcesGetResponse(BaseModel):
    sources: List[ConnectorSource]
    total: Optional[float] = Field(None, description='total number of results')


class BanksIdConnectorSourcesIdConnectorSourceFieldsGetResponse(BaseModel):
    source_fields: List[ConnectorSourceField]
    total: Optional[float] = Field(None, description='total number of results')


class CategoriesGetResponse(BaseModel):
    categories: List[Category]
    total: Optional[float] = Field(None, description='total number of results')


class CategorizePostRequest(BaseModel):
    type: str = Field(..., description='type of the transaction (default: unknown)')
    value: int = Field(..., description='value of the transaction')
    wording: str = Field(..., description='label of the transaction')


class CategorizePostResponse(BaseModel):
    pass


class ClientsGetResponse(BaseModel):
    clients: List[Client]
    total: Optional[float] = Field(None, description='total number of results')


class ClientsPostRequest(BaseModel):
    config: Optional[str] = Field(None, description='custom config about the client')
    generate_keys: Optional[bool] = Field(
        None,
        description='if True, generate a rsa pair of keys so the client can be used to generate jwt user tokens (default: False)',
    )
    name: Optional[str] = Field(None, description='name of client')
    redirect_uris: Optional[str] = Field(
        None, description='list of allowed redirect uris'
    )


class ClientsIdClientPutRequest(BaseModel):
    config: Optional[str] = Field(None, description='custom config about the client')
    description: Optional[str] = Field(
        None, description='text to display as a default description'
    )
    description_banks: Optional[str] = Field(
        None, description='text to display as a description for banks'
    )
    description_providers: Optional[str] = Field(
        None, description='text to display as a description for providers'
    )
    generate_keys: Optional[bool] = Field(
        None,
        description='set a rsa key pair for the client, which make it possible to generate a jwt user token using this client. No effect if the client already has a set of keys(default: False)',
    )
    name: Optional[str] = Field(None, description='name of client')
    primary_color: Optional[str] = Field(
        None, description='hexadecimal code of the client primary color (e.g F45B9A)'
    )
    pro: Optional[bool] = Field(
        None, description='Wether the client should display the company manager page'
    )
    redirect_uris: Optional[str] = Field(
        None, description='list of allowed redirect uris'
    )
    secondary_color: Optional[str] = Field(
        None, description='hexadecimal code of the client secondary color (e.g F45B9A)'
    )
    secret: Optional[bool] = Field(None, description='reset the secret')
    update_config: Optional[bool] = Field(
        None,
        description='update the custom information about the client instead of replacing the existing one (default: True)',
    )


class ConfigLogsGetResponse(BaseModel):
    configlogs: List[ConfigLog]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectionsGetResponse(BaseModel):
    connections: List[Connection]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectionsIdConnectionLogsGetResponse(BaseModel):
    connectionlogs: List[ConnectionLog]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectionsIdConnectionSourcesGetResponse(BaseModel):
    sources: List[ConnectionSource]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectionsIdConnectionSourcesIdSourcePostRequest(BaseModel):
    disabled: Optional[bool] = Field(
        None, description='to enable or disable connector source'
    )
    synchronize: Optional[bool] = Field(
        None,
        description="whether to force a synchronization on the source if it's not disabled",
    )


class ConnectionsIdConnectionSourcesIdSourcePutRequest(BaseModel):
    disabled: Optional[bool] = Field(
        None, description='to enable or disable connector source'
    )
    force: Optional[bool] = Field(
        None,
        description="whether to force the synchronization on the source if it's in error",
    )
    synchronize: Optional[bool] = Field(
        None,
        description="whether to force a synchronization on the source if it's not disabled",
    )


class ConnectorsGetResponse(BaseModel):
    connectors: List[Connector]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectorsPostRequest(BaseModel):
    comment: Optional[str] = Field(None, description='Optionnal comment')
    email: Optional[str] = Field(None, description='Email of the user')
    login: str = Field(..., description='Users login')
    name: str = Field(..., description='Name of the bank or provider')
    password: str = Field(..., description='Users password')
    sendmail: Optional[bool] = Field(None, description='if set, send an email to user')
    types: Optional[str] = Field(
        None, description='Type of connector, eg. banks or providers'
    )
    url: Optional[str] = Field(None, description='Url of the bank')


class ConnectorsPutRequest(BaseModel):
    hidden: Optional[bool] = Field(
        None, description='to enable  or disable connector (bank or provider)'
    )


class ConnectorsIdConnectorPutRequest(BaseModel):
    auth_mechanism: Optional[str] = Field(
        None, description='the authentication mechanism to use for this connector'
    )
    hidden: Optional[bool] = Field(
        None, description='to enable  or disable connector (bank or provider)'
    )
    id_categories: Optional[str] = Field(
        None,
        description='one or several comma separated categories to map to the given connector (or null to map no category)',
    )
    sync_frequency: Optional[int] = Field(
        None, description='Allows you to overload global sync_frequency param'
    )


class ConnectorsIdConnectorLogosGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectorsIdConnectorLogosMainGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectorsIdConnectorLogosThumbnailGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectorsIdConnectorSourcesGetResponse(BaseModel):
    sources: List[ConnectorSource]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectorsIdConnectorSourcesPutRequest(BaseModel):
    disabled_capabilities: Optional[str] = Field(
        None,
        description='list (json format) of capabilities the sources will be disabled for',
    )
    unavailable_capabilities: Optional[str] = Field(
        None,
        description='list (json format) of capabilities the sources will be unavailable for',
    )


class ConnectorsIdConnectorSourcesIdConnectorSourceFieldsGetResponse(BaseModel):
    source_fields: List[ConnectorSourceField]
    total: Optional[float] = Field(None, description='total number of results')


class ConnectorsIdConnectorSourcesIdSourcePutRequest(BaseModel):
    auth_mechanism: Optional[str] = Field(
        None,
        description='the authentication mechanism to use for this connector source',
    )
    disabled: Optional[bool] = Field(
        None, description='to enable or disable connector source'
    )
    disabled_capabilities: Optional[str] = Field(
        None,
        description='list (json format) of capabilities this source will be disabled for',
    )
    unavailable: Optional[bool] = Field(
        None,
        description='to enable or disable the source (can only be edited by BI employees)',
    )
    unavailable_capabilities: Optional[str] = Field(
        None,
        description='list (json format) of capabilities this source will be unavailable for',
    )


class LogsGetResponse(BaseModel):
    connectionlogs: List[ConnectionLog]
    total: Optional[float] = Field(None, description='total number of results')


class ProvidersGetResponse(BaseModel):
    providers: List[Connector]
    total: Optional[float] = Field(None, description='total number of results')


class ProvidersIdConnectorConnectionsGetResponse(BaseModel):
    connections: List[Connection]
    total: Optional[float] = Field(None, description='total number of results')


class ProvidersIdConnectorLogosGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class ProvidersIdConnectorLogosMainGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class ProvidersIdConnectorLogosThumbnailGetResponse(BaseModel):
    connectorlogos: List[ConnectorLogo]
    total: Optional[float] = Field(None, description='total number of results')


class ProvidersIdConnectorSourcesGetResponse(BaseModel):
    sources: List[ConnectorSource]
    total: Optional[float] = Field(None, description='total number of results')


class ProvidersIdConnectorSourcesIdConnectorSourceFieldsGetResponse(BaseModel):
    source_fields: List[ConnectorSourceField]
    total: Optional[float] = Field(None, description='total number of results')


class Psd2RegistrationsGetResponse(BaseModel):
    psd2registrations: List[Psd2Registration]
    total: Optional[float] = Field(None, description='total number of results')


class Psd2RegistrationsIdPsd2registrationLogsGetResponse(BaseModel):
    psd2registrationlogs: List[Psd2RegistrationLog]
    total: Optional[float] = Field(None, description='total number of results')


class UsersGetResponse(BaseModel):
    total: Optional[float] = Field(None, description='total number of results')
    users: List[User]


class UsersIdUserAccountTypesGetResponse(BaseModel):
    accounttypes: List[AccountType]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserAccountsIdAccountTransactionsclustersGetResponse(BaseModel):
    total: Optional[float] = Field(None, description='total number of results')
    transactionsclusters: List[TransactionsCluster]


class UsersIdUserAlertsGetResponse(BaseModel):
    alerts: List[Alert]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserCategoriesFullGetResponse(BaseModel):
    categorys: List[Category]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserCategoriesFullPostRequest(BaseModel):
    accountant_account: Optional[str] = Field(
        None, description='Accountant account number.'
    )
    color: Optional[str] = Field(None, description='Color of the category.')
    id_parent_category: Optional[int] = Field(
        None, description='ID of the parent category.'
    )
    id_parent_category_in_menu: Optional[int] = Field(
        None, description='ID of the parent category to be displayed.'
    )
    income: Optional[bool] = Field(
        None,
        description='Is an income category. If null, this is both an income and an expense category.',
    )
    name: Optional[str] = Field(None, description='Name of the category.')
    refundable: Optional[bool] = Field(
        None, description='This category accepts opposite sign of transactions.'
    )


class UsersIdUserCategoriesFullIdFullPutRequest(BaseModel):
    accountant_account: Optional[str] = Field(
        None, description='Accountant account number.'
    )
    hide: Optional[str] = Field(
        None, description='Hide (but not delete) a category. Must be 0, 1 or toggle.'
    )


class UsersIdUserConfigGetResponse(BaseModel):
    pass


class UsersIdUserConnectionsGetResponse(BaseModel):
    connections: List[Connection]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserConnectionsPostRequest(BaseModel):
    connector_uuid: Optional[str] = Field(
        None, description='optional uuid of the connector (replaces id_connector)'
    )
    id_connector: Optional[int] = Field(None, description='ID of the connector')


class UsersIdUserConnectionsIdConnectionPostRequest(BaseModel):
    active: Optional[bool] = Field(
        None, description='Set if the connection synchronization is active'
    )
    decoupled: Optional[bool] = Field(
        None, description='Try to update a connection with the decoupled error'
    )
    expire: Optional[datetime_aliased] = Field(
        None, description='Set expiration of the connection to this date'
    )
    login: Optional[str] = Field(None, description='Set login to this new login')
    password: Optional[str] = Field(
        None, description='Set password to this new password'
    )


class UsersIdUserConnectionsIdConnectionAccountsGetResponse(BaseModel):
    accounts: List[Account]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserConnectionsIdConnectionAccountsPostRequest(BaseModel):
    balance: Optional[float] = Field(None, description='balance of account')
    iban: Optional[str] = Field(None, description='IBAN of account')
    id_connection: Optional[int] = Field(
        None, description='the connection to attach to the account'
    )
    id_currency: Optional[str] = Field(
        None, description="the currency of the account (default: 'EUR')"
    )
    name: str = Field(..., description='name of account')
    number: Optional[str] = Field(None, description='number of account')


class UsersIdUserConnectionsIdConnectionAccountsIdAccountPutRequest(BaseModel):
    balance: Optional[float] = Field(None, description='Balance of the account')
    bookmarked: Optional[bool] = Field(None, description='If the account is bookmarked')
    disabled: Optional[bool] = Field(
        None, description='If the account is disabled (not synchronized)'
    )
    display: Optional[bool] = Field(None, description='If the account is displayed')
    iban: Optional[str] = Field(None, description='IBAN of the account')
    name: Optional[str] = Field(None, description='Label of the account')
    usage: Optional[str] = Field(
        None, description='Usage of the account : PRIV, ORGA or ASSO'
    )


class UsersIdUserConnectionsIdConnectionAccountsIdAccountLogsGetResponse(BaseModel):
    accountlogs: List[AccountLog]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserConnectionsIdConnectionAccountsIdAccountSourcesGetResponse(BaseModel):
    sources: List[ConnectionSource]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsGetResponse(
    BaseModel
):
    total: Optional[float] = Field(None, description='total number of results')
    transactions: List[Transaction]


class UsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsPostRequest(
    BaseModel
):
    active: Optional[bool] = Field(
        None,
        description='1 if the transaction should be taken into account by pfm services (default: 1)',
    )
    coming: Optional[bool] = Field(
        None, description='1 if the transaction has already been debited (default: 0)'
    )
    date: date_aliased = Field(..., description='date of the transaction')
    date_scraped: Optional[datetime_aliased] = Field(
        None,
        description='date on which the transaction has been found for the first time. YYYY-MM-DD HH:MM:SS(default: now)',
    )
    id_account: Optional[int] = Field(
        None,
        description='account of the transaction. If not supplied, it has to be given in the route',
    )
    original_wording: str = Field(..., description='label of the transaction')
    rdate: Optional[date_aliased] = Field(
        None, description='realisation date of the transaction (default: value of date)'
    )
    state: Optional[str] = Field(
        None, description='nature of the transaction (default: new)'
    )
    type: Optional[str] = Field(
        None, description='type of the transaction (default: unknown)'
    )
    value: int = Field(..., description='vallue of the transaction')


class UsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionPutRequest(
    BaseModel
):
    active: Optional[bool] = Field(
        None,
        description="if false, transaction isn't considered in analyzisis endpoints (like /balances)",
    )
    application_date: Optional[date_aliased] = Field(
        None, description='change application date of the transaction'
    )
    comment: Optional[str] = Field(None, description='change comment')
    id_category: Optional[int] = Field(
        None, description='ID of the associated category'
    )
    wording: Optional[str] = Field(
        None, description='user rewording of the transaction'
    )


class UsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsIdTransactionInformationsGetResponse(
    BaseModel
):
    total: Optional[float] = Field(None, description='total number of results')
    transactioninformations: List[TransactionInformation]


class UsersIdUserConnectionsIdConnectionAccountsIdAccountTransactionsclustersGetResponse(
    BaseModel
):
    total: Optional[float] = Field(None, description='total number of results')
    transactionsclusters: List[TransactionsCluster]


class UsersIdUserConnectionsIdConnectionInformationsGetResponse(BaseModel):
    connections: List[Connection]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserConnectionsIdConnectionLogsGetResponse(BaseModel):
    connectionlogs: List[ConnectionLog]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserConnectionsIdConnectionSourcesGetResponse(BaseModel):
    sources: List[ConnectionSource]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserConnectionsIdConnectionSourcesIdSourcePostRequest(BaseModel):
    disabled: Optional[bool] = Field(
        None, description='to enable or disable connector source'
    )
    synchronize: Optional[bool] = Field(
        None,
        description="whether to force a synchronization on the source if it's not disabled",
    )


class UsersIdUserConnectionsIdConnectionSourcesIdSourcePutRequest(BaseModel):
    disabled: Optional[bool] = Field(
        None, description='to enable or disable connector source'
    )
    force: Optional[bool] = Field(
        None,
        description="whether to force the synchronization on the source if it's in error",
    )
    synchronize: Optional[bool] = Field(
        None,
        description="whether to force a synchronization on the source if it's not disabled",
    )


class UsersIdUserConnectionsIdConnectionTransactionsclustersGetResponse(BaseModel):
    total: Optional[float] = Field(None, description='total number of results')
    transactionsclusters: List[TransactionsCluster]


class UsersIdUserLogsGetResponse(BaseModel):
    connectionlogs: List[ConnectionLog]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserProfilesGetResponse(BaseModel):
    profiles: List[Profile]
    total: Optional[float] = Field(None, description='total number of results')


class UsersIdUserTokenPostRequest(BaseModel):
    application: str = Field(..., description='application name')


class UsersIdUserTokenPostResponse(BaseModel):
    pass


class UsersIdUserTransactionsclustersGetResponse(BaseModel):
    total: Optional[float] = Field(None, description='total number of results')
    transactionsclusters: List[TransactionsCluster]


class WebauthGetRequest(BaseModel):
    client_id: Optional[int] = Field(None, description='Client Application ID')
    id_transfer: Optional[int] = Field(None, description='ID of the transfer')
    redirect_uri: Optional[str] = Field(None, description='Redirect URI')
    state: Optional[str] = Field(None, description='Optional state')


class WebhooksGetResponse(BaseModel):
    total: Optional[float] = Field(None, description='total number of results')
    webhooks: List[Webhook]


class WebhooksPostRequest(BaseModel):
    event: Optional[str] = Field(None, description='The webhook event')
    id_auth: Optional[str] = Field(
        None,
        description='The webhook authentication process to use (its ID or its name)',
    )
    id_service: Optional[int] = Field(
        None, description='The service ID to associate with the webhook'
    )
    id_user: Optional[int] = Field(
        None, description='The user ID to associate with the webhook'
    )
    params: Optional[str] = Field(
        None,
        description='The webhook parameters as an object with three keys: type, key and value',
    )
    url: Optional[str] = Field(None, description='The webhook callback url')


class WebhooksAuthGetResponse(BaseModel):
    authproviders: List[AuthProvider]
    total: Optional[float] = Field(None, description='total number of results')


class WebhooksAuthPostRequest(BaseModel):
    config: Optional[str] = Field(
        None,
        description='The authentication process configuration. A dict contains either the certificate',
    )
    name: str = Field(
        ..., description='The name of the authentication process to differentiate'
    )
    type: int = Field(
        ...,
        description='The type of the authentication process (oauth, certificate, token, etc...)',
    )


class WebhooksAuthIdAuthPostRequest(BaseModel):
    config: Optional[str] = Field(
        None,
        description='The authentication process configuration. A dict containing either the certificate',
    )
    name: str = Field(
        ..., description='The name of the authentication process to differentiate'
    )
    type: int = Field(
        ...,
        description='The type of the authentication process (oauth, certificate, token, etc...)',
    )


class WebhooksAuthIdAuthPutRequest(BaseModel):
    config: Optional[str] = Field(
        None,
        description='The authentication process configuration. A dict containt either the certificate',
    )
    name: str = Field(
        ..., description='The name of the authentication process to differentiate'
    )
    type: int = Field(
        ...,
        description='The type of the authentication process (oauth, certificate, token, etc...)',
    )


class WebhooksIdWebhookPostRequest(BaseModel):
    deleted: Optional[str] = Field(
        None, description="a date to delete the webhook or 'null' to enable it"
    )
    event: Optional[str] = Field(None, description='The webhook event')
    id_auth: Optional[int] = Field(
        None, description='The webhook authentication process to use'
    )
    id_service: Optional[int] = Field(
        None, description='The service ID to associate with the webhook'
    )
    id_user: Optional[int] = Field(
        None, description='The user ID to associate with the webhook'
    )
    url: Optional[str] = Field(None, description='The webhook callback url')


class WebhooksIdWebhookPutRequest(BaseModel):
    deleted: Optional[str] = Field(
        None, description="a date to delete the webhook or 'null' to enable it"
    )
    event: Optional[str] = Field(None, description='The webhook event')
    id_auth: Optional[int] = Field(
        None, description='The webhook authentication process to use'
    )
    id_service: Optional[int] = Field(
        None, description='The service ID to associate with the webhook'
    )
    id_user: Optional[int] = Field(
        None, description='The user ID to associate with the webhook'
    )
    url: Optional[str] = Field(None, description='The webhook callback url')


class WebhooksIdWebhookAddToDataGetResponse(BaseModel):
    total: Optional[float] = Field(None, description='total number of results')
    webhooks: List[Webhook]


class WebhooksIdWebhookLogsGetResponse(BaseModel):
    total: Optional[float] = Field(None, description='total number of results')
    webhooklogs: List[WebhookLog]
